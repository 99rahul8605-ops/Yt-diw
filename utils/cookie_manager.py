import json
import hashlib
from pathlib import Path
from typing import Optional, Dict, List
import re

class CookieManager:
    def __init__(self, cookies_dir: Path):
        self.cookies_dir = cookies_dir
        self.cookies_dir.mkdir(exist_ok=True)
        
        # YouTube-specific cookie domains
        self.youtube_domains = [
            '.youtube.com',
            'www.youtube.com',
            'youtube.com',
            '.youtube-nocookie.com',
            'www.youtube-nocookie.com',
            'm.youtube.com',
        ]
    
    def update_cookies(self, cookies_file_path: Path, user_id: int) -> Dict[str, any]:
        """Update cookies file for a user and return validation results."""
        try:
            # Read cookies file
            with open(cookies_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Validate cookies
            validation = self._validate_and_fix_cookies(content)
            
            if not validation['is_valid']:
                return {
                    'success': False,
                    'message': f"‚ùå {validation['message']}"
                }
            
            # Create user-specific cookies file
            user_cookies_path = self.cookies_dir / f"cookies_{user_id}.txt"
            
            # Write validated cookies
            with open(user_cookies_path, 'w', encoding='utf-8') as dst:
                dst.write(validation['fixed_content'])
            
            # Also create a default cookies file
            default_path = self.cookies_dir / "cookies.txt"
            with open(default_path, 'w', encoding='utf-8') as default_file:
                default_file.write(validation['fixed_content'])
            
            # Count YouTube-specific cookies
            youtube_cookies = self._count_youtube_cookies(validation['fixed_content'])
            
            return {
                'success': True,
                'message': (
                    f"‚úÖ **Cookies updated successfully!**\n\n"
                    f"üìä **Stats:**\n"
                    f"‚Ä¢ Total cookies: {validation['cookie_count']}\n"
                    f"‚Ä¢ YouTube cookies: {youtube_cookies}\n"
                    f"‚Ä¢ Format: {validation.get('format', 'Netscape')}\n\n"
                    f"üéØ **Now you can download:**\n"
                    f"‚Ä¢ Age-restricted videos\n"
                    f"‚Ä¢ Private/unlisted videos\n"
                    f"‚Ä¢ Avoid 'not a bot' errors"
                ),
                'cookie_count': validation['cookie_count'],
                'youtube_cookies': youtube_cookies,
                'has_login_cookies': self._has_login_cookies(validation['fixed_content'])
            }
            
        except Exception as e:
            print(f"Error updating cookies: {e}")
            return {
                'success': False,
                'message': f"‚ùå Error processing cookies file:\n{str(e)[:200]}"
            }
    
    def _validate_and_fix_cookies(self, content: str) -> Dict[str, any]:
        """Validate and fix cookies file format."""
        lines = content.strip().split('\n')
        
        # Check if empty
        if not lines or len(lines) < 2:
            return {
                'is_valid': False,
                'message': 'File is empty or too short'
            }
        
        # Check for Netscape format header
        is_netscape = lines[0].startswith('# HTTP') or lines[0].startswith('# Netscape')
        
        # Count valid cookie lines
        cookie_count = 0
        fixed_lines = []
        
        if is_netscape:
            # Keep header
            fixed_lines.append('# HTTP Cookie File')
            fixed_lines.append('# This file was generated by YouTube Downloader Bot')
            
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#'):
                    parts = line.split('\t')
                    if len(parts) >= 7:
                        # Validate domain
                        domain = parts[0]
                        if any(yt_domain in domain for yt_domain in self.youtube_domains):
                            cookie_count += 1
                            fixed_lines.append(line)
                        else:
                            # Keep non-YouTube cookies too
                            cookie_count += 1
                            fixed_lines.append(line)
        else:
            # Try to parse as simple key=value format
            fixed_lines.append('# HTTP Cookie File')
            fixed_lines.append('# Converted from simple format')
            
            for line in lines:
                line = line.strip()
                if line and '=' in line:
                    # Simple conversion to Netscape format
                    if 'youtube.com' in line.lower():
                        # Try to parse
                        parts = line.split(';')
                        key_value = parts[0].strip()
                        if '=' in key_value:
                            key, value = key_value.split('=', 1)
                            netscape_line = f".youtube.com\tTRUE\t/\tFALSE\t253402300800\t{key}\t{value}"
                            fixed_lines.append(netscape_line)
                            cookie_count += 1
        
        fixed_content = '\n'.join(fixed_lines)
        
        return {
            'is_valid': cookie_count > 0,
            'message': f"Found {cookie_count} cookies",
            'fixed_content': fixed_content,
            'cookie_count': cookie_count,
            'format': 'Netscape' if is_netscape else 'Converted'
        }
    
    def _count_youtube_cookies(self, content: str) -> int:
        """Count YouTube-specific cookies."""
        count = 0
        lines = content.strip().split('\n')
        
        for line in lines:
            if any(domain in line for domain in self.youtube_domains):
                count += 1
        
        return count
    
    def _has_login_cookies(self, content: str) -> bool:
        """Check if cookies contain login/session cookies."""
        login_indicators = [
            'LOGIN_INFO', 'SID', 'HSID', 'SSID', 'APISID', 
            'SAPISID', 'YSC', 'VISITOR_INFO1_LIVE', 'PREF',
            'SOCS', 'CONSENT'
        ]
        
        content_upper = content.upper()
        for indicator in login_indicators:
            if indicator in content_upper:
                return True
        
        return False
    
    def get_cookies_path(self, user_id: int) -> Optional[Path]:
        """Get cookies file path for a user."""
        # Try user-specific cookies first
        user_cookies_path = self.cookies_dir / f"cookies_{user_id}.txt"
        if user_cookies_path.exists():
            return user_cookies_path
        
        # Try default cookies
        default_cookies = self.cookies_dir / "cookies.txt"
        if default_cookies.exists():
            return default_cookies
        
        return None
    
    def has_cookies(self, user_id: Optional[int] = None) -> bool:
        """Check if cookies are available."""
        if user_id:
            return self.get_cookies_path(user_id) is not None
        else:
            return any(self.cookies_dir.glob("cookies*.txt"))
    
    def get_cookies_status(self, user_id: int) -> Dict[str, any]:
        """Get detailed cookies status."""
        path = self.get_cookies_path(user_id)
        
        if not path or not path.exists():
            return {
                'has_cookies': False,
                'message': '‚ùå No cookies configured\nUse /update_cookies to add cookies'
            }
        
        try:
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            youtube_count = self._count_youtube_cookies(content)
            has_login = self._has_login_cookies(content)
            file_size_kb = path.stat().st_size / 1024
            
            status_msg = (
                f"‚úÖ **Cookies configured**\n"
                f"‚Ä¢ YouTube cookies: {youtube_count}\n"
                f"‚Ä¢ Login cookies: {'‚úÖ Yes' if has_login else '‚ùå No'}\n"
                f"‚Ä¢ File size: {file_size_kb:.1f} KB"
            )
            
            if not has_login:
                status_msg += "\n‚ö†Ô∏è **Note:** May not work for age-restricted videos"
            
            return {
                'has_cookies': True,
                'youtube_count': youtube_count,
                'has_login': has_login,
                'file_size_kb': file_size_kb,
                'message': status_msg
            }
        except Exception as e:
            return {
                'has_cookies': False,
                'message': f'‚ùå Error reading cookies: {str(e)[:100]}'
            }
